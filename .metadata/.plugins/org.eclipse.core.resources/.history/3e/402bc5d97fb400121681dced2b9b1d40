package com.comp4903.project.graphics.tile;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
import java.nio.ShortBuffer;

import javax.microedition.khronos.opengles.GL10;

import com.comp4903.project.graphics.GLRenderer;
import com.comp4903.project.graphics.model.MaterialLibrary;
import com.comp4903.project.graphics.model.Texture;

import android.content.Context;
import android.opengl.Matrix;

public class Hexagon {
	
	private Context context;

	public int[][] screenCoords = new int[5000][14];
	public int screenCoordCount;
	
	private float[] vec = new float[4];
	private float[] resultVec = new float[4];
	
	private float vertices[];
	
	private TileSetDefinition[] tileDefinitions = new TileSetDefinition[10];
	
	private short indices[] = {
		0, 5, 1, 1, 5, 4, 1, 4, 2, 2, 4, 3 	
	};		
	
	private FloatBuffer vertexBuffer;
	private ShortBuffer indexBuffer;	
		
	public Hexagon(GL10 gl, Context c) {
		
		float C = 1.0f;
		float A = 0.5f * C;
		float B = 0.8660254038f * C;
		
		context = c;
		
		vertices = new float[18];
		vertices[0] = 0; vertices[1] = 0; vertices[2] = B;
		vertices[3] = A; vertices[4] = 0; vertices[5] = 0;
		vertices[6] = A + C; vertices[7] = 0; vertices[8] = 0;
		vertices[9] = 2 * C; vertices[10] = 0; vertices[11] = B;
		vertices[12] = A + C; vertices[13] = 0; vertices[14] = 2 * B;
		vertices[15] = A; vertices[16] = 0; vertices[17] = 2 * B;		
		
		ByteBuffer vbb = ByteBuffer.allocateDirect(vertices.length * 4);
		vbb.order(ByteOrder.nativeOrder());
		vertexBuffer = vbb.asFloatBuffer();
		vertexBuffer.put(vertices);
		vertexBuffer.position(0);
		
		ByteBuffer ibb = ByteBuffer.allocateDirect(indices.length * 2);
		ibb.order(ByteOrder.nativeOrder());
		indexBuffer = ibb.asShortBuffer();
		indexBuffer.put(indices);
		indexBuffer.position(0);		
		
	}
	
	/*	READTILEDATA - reads the display specifications for the tile sets used
	 *  by the application, including texture coordinates and associated models
	 * 
	 */
	public void readTileData()
	{
		tileDefinitions[0] = new TileSetDefinition("textures/tiles/metals.xml", context);
		
		Texture t = new Texture(tileDefinitions[0].name, "tiles/" + tileDefinitions[0].texFileName, 0);
		int index = MaterialLibrary.addTexture(t);
		MaterialLibrary.loadTexture(index);
		
		for (int i = 0; i < tileDefinitions[0].numberOfTiles; i++)
		{
			ByteBuffer tbb = ByteBuffer.allocateDirect(12 * 4);
			tbb.order(ByteOrder.nativeOrder());
			tileDefinitions[0].tiles[i].UV = tbb.asFloatBuffer();
			tileDefinitions[0].tiles[i].UV.put(tileDefinitions[0].tiles[i].texcoords);
			tileDefinitions[0].tiles[i].UV.position(0);
		}
	}
	
	/*	DRAW - draws a hexagon with the specified texture
	 * 
	 * 	gl					OpenGL device
	 * 	transformMatrix		model-view transformation matrix
	 * 	projectionMatrix	projection matrix
	 *  typ					texture index
	 * 
	 */
	public void draw(GL10 gl, float[] transformMatrix, float[] projectionMatrix, int typ)
	{		
				
		int tex = tileDefinitions[0].tiles[typ].textureMap;
		gl.glBindTexture(GL10.GL_TEXTURE_2D, MaterialLibrary.texturenames[tex]);
		
		gl.glFrontFace(GL10.GL_CW);		
		gl.glEnable(GL10.GL_CULL_FACE); 
		gl.glCullFace(GL10.GL_BACK);

		gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
		gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);

		gl.glVertexPointer(3, GL10.GL_FLOAT, 0, vertexBuffer);		
		gl.glTexCoordPointer(2, GL10.GL_FLOAT, 0, tileDefinitions[0].tiles[typ].UV);

		gl.glDrawArrays(GL10.GL_TRIANGLE_FAN, 0, vertices.length / 3);
		
		gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
		gl.glDisableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
		gl.glDisable(GL10.GL_CULL_FACE);		
		
		float w = (float)GLRenderer.GLwidth / 2f;
		float h = (float)GLRenderer.GLheight / 2f;
		
		// compute screen co-ordinates for the picking routine
		for (int m = 0; m < 6; m++)
		{
			// get the vertex
			vec[0] = vertices[m * 3];
			vec[1] = vertices[m * 3 + 1];
			vec[2] = vertices[m * 3 + 2];
			vec[3] = 1.0f;
			
			Matrix.multiplyMV(resultVec, 0, transformMatrix, 0, vec, 0);
			Matrix.multiplyMV(vec, 0, projectionMatrix, 0, resultVec, 0);
			if (vec[3] == 0)
				vec[3] = 0.000001f;
			screenCoords[screenCoordCount][m * 2] = (int)(w + vec[0] / vec[3] * w);
			screenCoords[screenCoordCount][m * 2 + 1] = (int)(h - vec[1] / vec[3] * h);		
		}	
		
		screenCoordCount++;		
	
		
	}
		
}
